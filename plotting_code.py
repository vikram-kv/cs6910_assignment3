# Contains code for plotting attention heatmap and predictions in a table
import plotly.express as px
import torch
import numpy as np
import plotly.graph_objects as go
import pandas as pd
from torchaudio.functional import edit_distance as edit_dist

'''
    function to return the plotly attention heatmap for X_word against pred_word (predicted - decoder output)
    when the tar_word = true target. attn_matrix = matrix of attention weights returned by
    EncoderDecoder object.
'''
def generate_attention_heatmap(X_word, tar_word, pred_word, attn_matrix :torch.Tensor):
    # let <S> = <SOS> and <E> = <EOS>
    x_labels = list(pred_word) + ['<E>']
    y_labels = ['<S>'] + list(X_word) + ['<E>']
    # we ignore the 0th timestep as it was not generated by attn_layer
    # remember we did not stop inference when <EOS> was predicted. so, now we need
    # take the relevant entries from the attn matrix now.
    attn_matrix = np.transpose(attn_matrix[1:(len(x_labels) + 1),:].cpu().numpy())
    assert(len(x_labels) == attn_matrix.shape[1])
    assert(len(y_labels) == attn_matrix.shape[0])
    print(attn_matrix)
    fig = px.imshow(attn_matrix, x=x_labels, y=y_labels,text_auto=False)
    fig.update_layout(
          xaxis={'side': 'top'}, 
          yaxis={'side': 'left'},
          title = {'text' : f'\t\tSrc : {X_word}   Truth : {tar_word}   Pred : {pred_word}', 'font' : {'size':20}, 'xanchor' : 'left'}
    )
    return fig

'''
    Function that will assign a color to each prediction in the matrix (rows = number of test examples, cols = (x, y_true, y_pred1, y_pred2 ...)). 
    This will be useful for plotting the test errors in the report using plotly tables.
'''
def color_code(pd_df):
    colorlist = ["mediumseagreen", "lightgreen", "yellow", "orange", "tomato"]
    rws, cols = len(pd_df), len(pd_df.columns)
    colors = [['#FFFFFF' for _ in range(rws)] for _ in range(cols)]
    for i in range(rws):
        for j in range(1, cols):
            # compute edit distance between true word and predicted word
            true_word = pd_df.iat[i,1]
            pred_word = pd_df.iat[i,j]
            edit_distance = edit_dist(true_word, pred_word)
            clip_edit = min(edit_distance, 4)
            colors[j][i] = colorlist[clip_edit]
    return colors
'''
    pd_df is a dataframe where 1st col = X, 2nd col = y, 3rd col = y_pred1, 4th col = y_pred2 ....
    locs are the locations that we want to display.
'''
def generate_table_and_legend(pd_df, locs):
    # get the subframe with only the rows with index in locs
    df_fil = pd_df.filter(items=locs, axis=0)
    # generate colors and plot the table in plotly
    colors = color_code(df_fil)
    table = go.Table(header=dict(values=df_fil.columns),
                     cells=dict(values=[list(df_fil[c]) for c in df_fil.columns], fill_color=colors))
    fig1 = go.Figure(data=[table])

    # also generate the legend for the color coding as a plotly table
    colorlist = ["mediumseagreen", "lightgreen", "yellow", "orange", "tomato"]
    table = go.Table(header=dict(values=['Color', 'Levenshtein distance']),
                     cells=dict(values=[['' for _ in range(len(colorlist))], [i for i in range(4)] + ['>= 4']], 
                                fill_color=[colorlist, ['#FFFFFF' for _ in range(len(colorlist))]]
                                ))
    fig2 = go.Figure(data=[table])
    return fig1, fig2